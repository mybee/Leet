package main

// 利用外部空间
//这种方式很简单，先申请一个动态扩容的数组或者容器，比如ArrayList这样的。
//然后不断遍历链表，将链表中的元素添加到这个容器中。
//再利用容器自身的API，反转整个容器，这样就达到反转的效果了。
//最后同时遍历容器和链表，将链表中的值改为容器中的值。
//因为此时容器的值是：
//
//5 4 3 2 1
//链表按这个顺序重新被设置一边，就达到要求啦。
//当然你可以可以再新创建N个节点，然后再返回，这样也可以达到目的。
//这种方式很简单，但你在面试中这么做的话，面试官100%会追问是否有更优的方式，比如不用外部空间。所以我就不做代码和动画演示了，下面来看看如何用O(1)空间复杂度来实现这道题。
//
//双指针迭代
//我们可以申请两个指针，第一个指针叫pre，最初是指向null的。
//第二个指针cur指向head，然后不断遍历cur。
//每次迭代到cur，都将cur的next指向pre，然后pre和cur前进一位。
//都迭代完了(cur变成null了)，pre就是最后一个节点了。
//动画演示如下：
//
//
//代码实现：
//
//javapython
//class Solution {
//	public ListNode reverseList(ListNode head) {
//		//申请节点，pre和 cur，pre指向null
//		ListNode pre = null;
//		ListNode cur = head;
//		ListNode tmp = null;
//		while(cur!=null) {
//			//记录当前节点的下一个节点
//			tmp = cur.next;
//			//然后将当前节点指向pre
//			cur.next = pre;
//			//pre和cur节点都前进一位
//			pre = cur;
//			cur = tmp;
//		}
//		return pre;
//	}
//}
//递归解法
//这题有个很骚气的递归解法，递归解法很不好理解，这里最好配合代码和动画一起理解。
//递归的两个条件：
//
//终止条件是当前节点或者下一个节点==null
//在函数内部，改变节点的指向，也就是head的下一个节点指向head 递归函数那句
//head.next.next = head
//很不好理解，其实就是head的下一个节点指向head。
//递归函数中每次返回的cur其实只最后一个节点，在递归函数内部，改变的是当前节点的指向。
//动画演示如下：
//
//
//代码实现：
