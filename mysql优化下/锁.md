1. 使用连接池

2. 减少对mysql的访问
    一次能获取的不要多次获取


3. 增加cache层.

4. 负载均衡(多台mysql服务器(从复制), 读写分离)

查询缓存

1. 相同的sql语句会命中缓存, 表数据改后, 缓存失效


锁

1. 锁: 避免资源的争抢

2. 
   对数据操作粒度分:
    表锁:  操作时, 会锁定整个表
    行锁:  操作时, 会锁定当前操作行
   对数据操作类型分:


3. mysiam:
    读锁: 不影响其他客户端的读操作, 阻塞写操作

InnoDB 行锁

1. 默认行锁:
    开销大, 加锁慢, 会出现死锁, 锁定粒度小, 发生冲突概率最小 并发度最高

2. 事务的四个特性:
    原子性: 事务是一个原子操作
    一致性: 在数据开始和完成时, 数据必须保持一致状态
    隔离性: 
    持久性: 修改是永久的

3. 行锁升级为表锁:
    where 条件进行类型转化, 导致索引失效时, 会变为表锁.


并发事务带来的问题:
  1. 丢失更新
  2. 脏读
  3. 不可重复读
  4. 幻读
通过隔离级别来解决并发问题:
    1. 读不提交
    2. 读已提交
    3. 重复读
    4. 序列化
    
间隙锁:

1. 当我们使用范围条件, 而不是使用相等条件检索数据, 并请求共享锁或排他锁时, 对于键值在条件范围内但不存在的记录, 叫做间隙

行锁争用情况:

锁相关的优化建议:
    1. 尽可能让所有的数据都能通过索引来完成, 避免行锁升级为表锁
    2. 合理设计索引, 尽量缩小锁的范围
    3. 尽可能减少索引条件, 及索引范围, 避免间隙锁
    4. 尽量控制事务大小, 减少锁定资源量和时间长度
    5. 尽可能使用低级别的事务隔离(满足业务的前提)
    


// mysql 工具

// 

// 系统性能优化
// 1. 分页

//   1. 优化 count
        
        新建一个表, 这个表只记录 数量.
        每次插入的时候更新数量即可.

//   2. 优化 limit

       前面的页面查询不耗时, 后面的页面非常耗时
       解决:
        使用 主键索引 :
        select * from table a , (select id from table order by id  limit 30000, 10 )b where a.id = b.id
   
   2. 索引
   
       1. 创建复合索引
       
       2.
            
   3. 排序
        
        1.   
        
   4. 读写分离
   
    